<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Jira Timesheet</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 0; padding: 0; background: #f6f7f9; }
    header { background: #0747a6; color: white; padding: 1px 16px; display: flex; align-items: center; justify-content: space-between; }
    header a { color: white; text-decoration: none; font-weight: bold; }
    main { padding: 16px; max-width: 1000px; margin: 0 auto; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    select, input, button, textarea { padding: 8px; font-size: 14px; }
    .card { background: white; border-radius: 8px; padding: 12px; margin: 12px 0; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 8px; border-bottom: 1px solid #eee; }
    .muted { color: #666; }
    .right { text-align: right; }
    .danger { color: #b71c1c; }
    .day-header { background: #f0f4ff; font-weight: 600; }
    .day-header .right { font-weight: 700; }
  </style>
</head>
<body>
  <header>
    <h2>Jira Timesheet</h2>
    <a href="/capacity.html">Capacity Planning</a>
  </header>
  <main>
    <div class="card">
      <div class="row">
        <label>Issue</label>
        <select id="issue" aria-busy="false"></select>
        <a id="issueLink" href="#" target="_blank" rel="noopener noreferrer" title="Open selected issue in Jira" aria-label="Open selected issue in Jira" style="display:none">ðŸ”—</a>
        <span id="issueStatus" class="muted" aria-live="polite"></span>
        <label>Date</label>
        <input type="date" id="date">
        <label>Start</label>
        <input type="time" id="start" step="60" value="09:00">
        <label>Duration</label>
        <input type="text" id="duration" placeholder="e.g. 1h 30m or 90m or 1.5h" value="1h">
        <button id="add">Log</button>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content: space-between; align-items: center;">
        <h3 style="margin:0">Worklogs</h3>
        <div class="row" aria-label="Week navigation">
          <span id="weekNumber" class="muted" title="Calendar week" aria-live="polite" style="min-width:48px;text-align:right"></span>
          <button id="prevWeek" title="Previous week" aria-label="Previous week">â—€</button>
          <input type="date" id="viewDate" aria-label="Any date within the week">
          <button id="nextWeek" title="Next week" aria-label="Next week">â–¶</button>
        </div>
      </div>
      <table>
        <thead>
          <tr>
            <th>Issue</th>
            <th>When</th>
            <th>Duration</th>
            <th class="right">Actions</th>
          </tr>
        </thead>
        <tbody id="logs"></tbody>
      </table>
    </div>
  </main>

  <script>
    const issueSelect = document.getElementById('issue');
    const dateInput = document.getElementById('date');
    const startInput = document.getElementById('start');
    const durationInput = document.getElementById('duration');
    const issueLink = document.getElementById('issueLink');
    const addBtn = document.getElementById('add');
    const logsTbody = document.getElementById('logs');
    const issueStatus = document.getElementById('issueStatus');
    const viewDateInput = document.getElementById('viewDate');
    const weekNumberSpan = document.getElementById('weekNumber');
    const prevWeekBtn = document.getElementById('prevWeek');
    const nextWeekBtn = document.getElementById('nextWeek');
    let jiraBaseUrl = '';

    // Caching issues and worklogs to avoid refetching everything on every change
    let cachedIssues = null; // array of issues
    const worklogCache = new Map(); // issueId -> worklogs[]
    const invalidatedIssueIds = new Set(); // issueIds whose worklogs must be refreshed

    function toJiraStarted(dateStr, timeStr) {
      // returns timezone offset, e.g., +0200
      const [h, m] = timeStr.split(':').map(Number);
      const d = new Date(dateStr + 'T' + timeStr + ':00');
      const pad = n => String(n).padStart(2, '0');
      const tz = -d.getTimezoneOffset();
      const sign = tz >= 0 ? '+' : '-';
      const abs = Math.abs(tz);
      const tzStr = sign + pad(Math.floor(abs / 60)) + pad(abs % 60);
      return d.getFullYear() + '-' + pad(d.getMonth()+1) + '-' + pad(d.getDate()) + 'T' + pad(h) + ':' + pad(m) + ':00.000' + tzStr;
    }

    async function loadConfig() {
      try {
        const res = await fetch('/api/config');
        if (!res.ok) return;
        const cfg = await res.json();
        if (cfg && typeof cfg.jiraBaseUrl === 'string') {
          // normalize: no trailing slash
          jiraBaseUrl = cfg.jiraBaseUrl.replace(/\/$/, '');
        }
      } catch (e) {
        console.warn('Failed to load config', e);
      }
    }

    function updateIssueLink() {
      try {
        if (!issueLink) return;
        const sel = issueSelect.options[issueSelect.selectedIndex];
        const key = sel?.dataset?.key;
        if (jiraBaseUrl && key) {
          issueLink.href = `${jiraBaseUrl}/browse/${key}`;
          issueLink.style.display = '';
          issueLink.title = `Open ${key} in Jira`;
          issueLink.setAttribute('aria-label', `Open ${key} in Jira`);
        } else {
          issueLink.style.display = 'none';
        }
      } catch {
        if (issueLink) issueLink.style.display = 'none';
      }
    }

    async function loadIssues() {
      try {
        issueSelect.disabled = true;
        addBtn.disabled = true;
        issueSelect.setAttribute('aria-busy','true');
        if (issueStatus) issueStatus.textContent = 'Loading issuesâ€¦';
        const res = await fetch('/api/issues');
        if (!res.ok) {
          const err = await res.json().catch(()=>({}));
          const msg = err.error || err.message || (err.errorMessages && err.errorMessages.join(', ')) || `HTTP ${res.status}`;
          if (issueStatus) issueStatus.textContent = `Failed to load issues: ${msg}`;
          throw new Error(msg);
        }
        const issues = await res.json();
        cachedIssues = issues; // cache issues
        issueSelect.innerHTML = '';
        issues.forEach(i => {
          const opt = document.createElement('option');
          opt.value = i.id;
          opt.textContent = `${i.key} â€” ${i.summary}`;
          opt.dataset.key = i.key;
          issueSelect.appendChild(opt);
        });
        updateIssueLink();
        if (issues.length === 0) {
          if (issueStatus) issueStatus.textContent = 'No issues found.';
        } else {
          if (issueStatus) {
            issueStatus.textContent = `Loaded ${issues.length} issues`;
            setTimeout(() => { if (issueStatus.textContent.startsWith('Loaded')) issueStatus.textContent = ''; }, 1200);
          }
        }
      } catch (e) {
        console.error(e);
        // Keep existing options if any; otherwise leave empty
      } finally {
        issueSelect.disabled = false;
        addBtn.disabled = false;
        issueSelect.setAttribute('aria-busy','false');
      }
    }

    function getTodayISODate() {
      const d = new Date();
      const pad = n => String(n).padStart(2, '0');
      return d.getFullYear() + '-' + pad(d.getMonth()+1) + '-' + pad(d.getDate());
    }

    function isSameDay(a, b) {
      return a.getFullYear()===b.getFullYear() && a.getMonth()===b.getMonth() && a.getDate()===b.getDate();
    }

    async function loadTodayWorklogs() {
      // Backward compatibility wrapper to load worklogs for the selected viewDate
      return loadWorklogsForSelectedDay();
    }

    async function loadWorklogsForSelectedDay() {
      // Deprecated in favor of weekly view; keep as shim
      return loadWorklogsForSelectedWeek();
    }

    function getMonday(d) {
      const date = new Date(d);
      const day = date.getDay(); // 0=Sun,1=Mon,...
      const diff = (day === 0 ? -6 : 1) - day; // shift to Monday
      date.setDate(date.getDate() + diff);
      date.setHours(0,0,0,0);
      return date;
    }

    function getISOWeekNumber(date) {
      // ISO week: weeks start on Monday, week 1 is the one with Jan 4th
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      // Set to nearest Thursday (current date + 4 - current day number) with Monday=1, Sunday=7
      const dayNum = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
      const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
      return weekNo;
    }

    function updateWeekNumberUI() {
      try {
        if (!weekNumberSpan) return;
        const ref = new Date(viewDateInput.value || getTodayISODate());
        const monday = getMonday(ref);
        const weekNo = getISOWeekNumber(monday);
        weekNumberSpan.textContent = `CW ${String(weekNo).padStart(2,'0')}`;
      } catch (e) {
        if (weekNumberSpan) weekNumberSpan.textContent = '';
      }
    }

    function formatISODate(d) {
      const pad = n => String(n).padStart(2,'0');
      return d.getFullYear() + '-' + pad(d.getMonth()+1) + '-' + pad(d.getDate());
    }

    async function loadAllIssues() {
      if (cachedIssues && Array.isArray(cachedIssues) && cachedIssues.length) {
        return cachedIssues;
      }
      if (issueStatus) issueStatus.textContent = 'Loading issuesâ€¦';
      try {
        const res = await fetch('/api/issues');
        if (!res.ok) {
          const err = await res.json().catch(()=>({}));
          const msg = err.error || err.message || (err.errorMessages && err.errorMessages.join(', ')) || `HTTP ${res.status}`;
          if (issueStatus) issueStatus.textContent = `Failed to load issues: ${msg}`;
          throw new Error(msg);
        }
        const issues = await res.json();
        cachedIssues = issues; // cache
        // keep the loading indicator until callers finish their flows; they can clear it explicitly
        return issues;
      } catch (e) {
        console.error(e);
        throw e;
      }
    }

    async function loadWorklogsForSelectedWeek() {
      logsTbody.innerHTML = '';
      // show loading row while fetching issues/worklogs
      const loadingTr = document.createElement('tr');
      loadingTr.innerHTML = '<td colspan="4" class="muted">Loading worklogsâ€¦</td>';
      logsTbody.appendChild(loadingTr);
      let allIssues;
      try {
        allIssues = await loadAllIssues();
      } catch (e) {
        logsTbody.innerHTML = '<tr><td colspan="4" class="danger">Cannot load worklogs because issues failed to load. Check server configuration and network.</td></tr>';
        // in case of error, keep the error message in issueStatus
        return;
      }
      // issues successfully loaded; update status to more stable message and clear it after a short delay to avoid flicker
      if (issueStatus) {
        const count = Array.isArray(allIssues) ? allIssues.length : 0;
        issueStatus.textContent = `Loaded ${count} issues`;
        setTimeout(() => { if (issueStatus.textContent.startsWith('Loaded')) issueStatus.textContent = ''; }, 1200);
      }
      logsTbody.innerHTML = '';
      const refDate = new Date(viewDateInput.value || getTodayISODate());
      const monday = getMonday(refDate);
      const weekDays = Array.from({length:7}, (_,i)=>{
        const d = new Date(monday);
        d.setDate(monday.getDate()+i);
        return d;
      });

      // Fetch worklogs per issue and group by day
      const dayGroups = weekDays.map(d => ({ date: new Date(d), logs: [] }));

      for (const issue of allIssues) {
        let list;
        // refresh cache if this issue was invalidated or not present
        if (invalidatedIssueIds.has(issue.id) || !worklogCache.has(issue.id)) {
          const res = await fetch(`/api/issues/${issue.id}/worklogs`);
          list = await res.json();
          worklogCache.set(issue.id, list);
        } else {
          list = worklogCache.get(issue.id);
        }
        list.forEach(w => {
          const started = new Date(w.started);
          for (let i=0;i<7;i++) {
            if (isSameDay(started, weekDays[i])) {
              dayGroups[i].logs.push({ ...w, issueId: issue.id, issueKey: issue.key, issueSummary: issue.summary });
              break;
            }
          }
        });
      }
      // clear invalidations after refresh
      invalidatedIssueIds.clear();

      // Render rows, ensuring a full week Mon-Sun with a header per day showing totals
      const dayNames = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
      for (let i=0;i<7;i++) {
        const group = dayGroups[i];
        // compute total minutes for the day
        const totalMinutes = group.logs.reduce((sum, w)=> sum + Math.round((w.timeSpentSeconds||0)/60), 0);
        // Day header row
        const headerTr = document.createElement('tr');
        headerTr.className = 'day-header';
        headerTr.innerHTML = `<td colspan="3">${dayNames[i]} ${formatISODate(group.date)}</td><td class="right">${formatMinutesAsHHMM(totalMinutes)}</td>`;
        logsTbody.appendChild(headerTr);

        if (group.logs.length === 0) {
          const emptyTr = document.createElement('tr');
          emptyTr.innerHTML = `<td colspan="4" class="muted">No worklogs</td>`;
          logsTbody.appendChild(emptyTr);
          continue;
        }
        // For groups with logs, render a row per log
        group.logs.sort((a,b)=> new Date(a.started)-new Date(b.started));
        group.logs.forEach((w) => {
          const tr = document.createElement('tr');
          const sum = (w.issueSummary || '').slice(0,25);
          const sumSuffix = (w.issueSummary || '').length > 25 ? 'â€¦' : '';
          const issueText = `${w.issueKey}${sum ? ' â€” ' + sum + sumSuffix : ''}`;
          const linkHtml = (jiraBaseUrl && w.issueKey) ? ` <a href="${jiraBaseUrl}/browse/${w.issueKey}" target="_blank" rel="noopener noreferrer" aria-label="Open ${w.issueKey} in Jira" title="Open ${w.issueKey} in Jira">ðŸ”—</a>` : '';
          tr.innerHTML = `
            <td>${issueText}${linkHtml}</td>
            <td>${new Date(w.started).toLocaleString()}</td>
            <td>${formatMinutesAsHHMM(Math.round((w.timeSpentSeconds||0)/60))}</td>
            <td class="right">
              <button data-act="edit">Edit</button>
              <button data-act="delete" class="danger">Delete</button>
            </td>`;
          const issueId = w.issueId;
          tr.querySelector('[data-act="edit"]').onclick = () => startEdit(issueId, w, tr);
          tr.querySelector('[data-act="delete"]').onclick = async () => {
            if (!confirm('Delete this worklog?')) return;
            const resp = await fetch(`/api/issues/${issueId}/worklogs/${w.id}`, { method: 'DELETE' });
            if (!resp.ok && resp.status!==204) {
              alert('Failed to delete');
              return;
            }
            // mark this issue as invalidated and refresh week using cache for others
            invalidatedIssueIds.add(issueId);
            await loadWorklogsForSelectedWeek();
          };
          logsTbody.appendChild(tr);
        });
      }
    }

    // Legacy single-row renderer (unused in weekly view)
    function addRow(issueId, w) {
      const tr = document.createElement('tr');
      const summary = (w.issueSummary || issueSelect.options[issueSelect.selectedIndex]?.textContent?.split(' â€” ')[1] || '').slice(0,25);
      const sumSuffix = (w.issueSummary || '').length > 25 ? 'â€¦' : '';
      const baseKey = (w.issueKey || issueSelect.options[issueSelect.selectedIndex]?.textContent?.split(' â€” ')[0]);
      const issueText = `${baseKey}${summary ? ' â€” ' + summary + sumSuffix : ''}`;
      const linkHtml = (jiraBaseUrl && baseKey) ? ` <a href="${jiraBaseUrl}/browse/${baseKey}" target="_blank" rel="noopener noreferrer" aria-label="Open ${baseKey} in Jira" title="Open ${baseKey} in Jira">ðŸ”—</a>` : '';
      tr.innerHTML = `
        <td>${issueText}${linkHtml}</td>
        <td>${new Date(w.started).toLocaleString()}</td>
        <td>${formatMinutesAsHHMM(Math.round((w.timeSpentSeconds||0)/60))}</td>
        <td class="right">
          <button data-act="edit">Edit</button>
          <button data-act="delete" class="danger">Delete</button>
        </td>`;
      tr.querySelector('[data-act="edit"]').onclick = () => startEdit(issueId, w, tr);
      tr.querySelector('[data-act="delete"]').onclick = async () => {
        if (!confirm('Delete this worklog?')) return;
        const resp = await fetch(`/api/issues/${issueId}/worklogs/${w.id}`, { method: 'DELETE' });
        if (!resp.ok && resp.status!==204) {
          alert('Failed to delete');
          return;
        }
        invalidatedIssueIds.add(issueId);
        await loadWorklogsForSelectedWeek();
      };
      logsTbody.appendChild(tr);
    }

    function getLocalDateTimeParts(iso) {
      const d = new Date(iso);
      const pad = n => String(n).padStart(2,'0');
      return {
        date: d.getFullYear() + '-' + pad(d.getMonth()+1) + '-' + pad(d.getDate()),
        time: pad(d.getHours()) + ':' + pad(d.getMinutes())
      };
    }

    function startEdit(issueId, w, tr) {
      const parts = getLocalDateTimeParts(w.started);
      const mins = Math.round((w.timeSpentSeconds||0)/60);
      const summary = (w.issueSummary || issueSelect.options[issueSelect.selectedIndex]?.textContent?.split(' â€” ')[1] || '').slice(0,25);
      const sumSuffix = (w.issueSummary || '').length > 25 ? 'â€¦' : '';
      const baseKey = (w.issueKey || issueSelect.options[issueSelect.selectedIndex]?.textContent?.split(' â€” ')[0]);
      const issueText = `${baseKey}${summary ? ' â€” ' + summary + sumSuffix : ''}`;
      const linkHtml = (jiraBaseUrl && baseKey) ? ` <a href="${jiraBaseUrl}/browse/${baseKey}" target="_blank" rel="noopener noreferrer" aria-label="Open ${baseKey} in Jira" title="Open ${baseKey} in Jira">ðŸ”—</a>` : '';
      tr.innerHTML = `
        <td>${issueText}${linkHtml}</td>
        <td>
          <input type="date" data-edit="date" value="${parts.date}">
          <input type="time" data-edit="time" step="60" value="${parts.time}">
        </td>
        <td>
          <input type="text" data-edit="duration" value="${mins}">
        </td>
        <td class="right">
          <button data-act="save">Save</button>
          <button data-act="cancel" class="danger">Cancel</button>
        </td>`;

      tr.querySelector('[data-act="cancel"]').onclick = () => {
        // Reload list to restore original row (use cache; no invalidation needed)
        loadWorklogsForSelectedWeek();
      };
      tr.querySelector('[data-act="save"]').onclick = async () => {
        const date = tr.querySelector('[data-edit="date"]').value;
        const time = tr.querySelector('[data-edit="time"]').value || '00:00';
        const durationStr = tr.querySelector('[data-edit="duration"]').value;
        const started = toJiraStarted(date, time);
        const minutes = parseJiraDurationToMinutes(durationStr);
        if (!date || !Number.isFinite(minutes) || minutes <= 0) {
          alert('Enter a valid date and duration (e.g., 1h 30m, 90m, 1.5h, 01:30).');
          return;
        }
        const body = { started, timeSpentSeconds: Math.round(minutes)*60 };
        const resp = await fetch(`/api/issues/${issueId}/worklogs/${w.id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        if (!resp.ok) {
          const err = await resp.json().catch(()=>({}));
          alert('Failed to update worklog: ' + (err.errorMessages || err.message || resp.status));
          return;
        }
        // Invalidate only this issue and refresh week using cache for others
        invalidatedIssueIds.add(issueId);
        await loadWorklogsForSelectedWeek();
      };
    }

    function formatMinutesAsHHMM(mins) {
      if (!Number.isFinite(mins)) return '';
      const h = Math.floor(mins/60);
      const m = mins % 60;
      return String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0');
    }

    function parseJiraDurationToMinutes(input) {
      if (!input) return NaN;
      const s = String(input).trim().toLowerCase();
      const hm = s.match(/^([0-9]{1,3}):(\d{2})$/);
      if (hm) {
        const h = parseInt(hm[1],10);
        const m = parseInt(hm[2],10);
        if (m>=60) return NaN;
        return h*60 + m;
      }
      const re = /([0-9]*\.?[0-9]+)\s*([wdhm])/g;
      let match; let totalMinutes = 0; let any=false;
      while ((match = re.exec(s))){
        any = true;
        const val = parseFloat(match[1]);
        const unit = match[2];
        if (unit==='w') totalMinutes += val*5*8*60;
        else if (unit==='d') totalMinutes += val*8*60;
        else if (unit==='h') totalMinutes += val*60;
        else if (unit==='m') totalMinutes += val;
      }
      if (any) return Math.round(totalMinutes);
      const num = parseFloat(s.replace(',','.'));
      if (Number.isFinite(num)) return Math.round(num);
      return NaN;
    }


    addBtn.onclick = async () => {
      const issueId = issueSelect.value;
      if (!issueId) return alert('Select an issue');
      const started = toJiraStarted(dateInput.value, startInput.value);
      const minutes = parseJiraDurationToMinutes(durationInput.value);
      if (!Number.isFinite(minutes) || minutes <= 0) return alert('Enter a valid duration (e.g., 1h 30m, 90m, 1.5h, 01:30)');
      const body = { started, timeSpentSeconds: Math.round(minutes) * 60 };
      const res = await fetch(`/api/issues/${issueId}/worklogs`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      if (!res.ok) {
        const err = await res.json().catch(()=>({}));
        alert('Failed to log time: ' + (err.errorMessages || err.message || res.status));
        return;
      }
      // Invalidate only the selected issue and refresh week using cache for others
      invalidatedIssueIds.add(issueId);
      await loadWorklogsForSelectedWeek();
    };

    function shiftViewWeeks(weeks) {
      const d = new Date(viewDateInput.value || getTodayISODate());
      d.setDate(d.getDate() + weeks*7);
      const pad = n => String(n).padStart(2, '0');
      viewDateInput.value = d.getFullYear() + '-' + pad(d.getMonth()+1) + '-' + pad(d.getDate());
      loadWorklogsForSelectedWeek();
      updateWeekNumberUI();
    }

    (function init() {
      const today = getTodayISODate();
      dateInput.value = today; // default for new worklogs
      viewDateInput.value = today; // default for viewing
      loadConfig().then(loadIssues).then(() => { loadWorklogsForSelectedWeek(); updateWeekNumberUI(); updateIssueLink(); });
      issueSelect.onchange = () => { updateIssueLink(); }; // do not reload when switching issue
      viewDateInput.onchange = () => { loadWorklogsForSelectedWeek(); updateWeekNumberUI(); };
      prevWeekBtn.onclick = () => shiftViewWeeks(-1);
      nextWeekBtn.onclick = () => shiftViewWeeks(1);
      // keyboard accessibility for arrows
      prevWeekBtn.onkeyup = (e) => { if (e.key === 'Enter' || e.key === ' ') shiftViewWeeks(-1); };
      nextWeekBtn.onkeyup = (e) => { if (e.key === 'Enter' || e.key === ' ') shiftViewWeeks(1); };

      // If issues failed to load, allow retry by clicking the status text
      if (issueStatus) {
        issueStatus.style.cursor = 'pointer';
        issueStatus.title = 'Click to retry loading issues';
        issueStatus.onclick = () => loadConfig().then(loadIssues).then(() => { loadWorklogsForSelectedWeek(); updateIssueLink(); });
      }
    })();
  </script>
</body>
</html>